/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {authToken, tenantId} from '../../../src/shared/api/config';
import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

import * as moment from 'moment';

export class AuthorizedApiBase {
  private readonly config: IConfig;

  protected constructor(config: IConfig) {
    this.config = config;
  }

  protected transformOptions = (options: RequestInit): Promise<RequestInit> => {
    options.headers = {
      ...options.headers,
      Authorization: this.config.getAuthorization(),
      TenantId: this.config.getTenantId(),
    };
    return Promise.resolve(options);
  };
  protected getBaseUrl(defaultUrl: string) {
    return this.config.baseUrl();
  }
  protected transformResult(
    url: string,
    response: Response,
    processor: (response: Response) => any,
  ) {
    // TODO: Return own result or throw exception to change default processing behavior,
    // or call processor function to run the default processing logic
    let _headers: any = {};
    const status = response.status;
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }

    console.log('Service call: ' + url);
    //return processor(response);
    let message = '';
    if (response.status == 200) {
      return processor(response);
    } else {
      switch (response.status) {
        case 400:
          message = 'bad request';
          break;
        case 401:
          message = 'unauthorized';
          break;
        case 403:
          message = 'forbidden';
          break;
        case 404:
          message = 'not found';
          break;
        case 500:
          message = 'server error';
          break;
        default:
          break;
      }
      return throwException(message, status, null, null);
    }
  }
}

export class AddOnClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getAddOn(
    productId?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfGetAddOnContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/addon?';
    if (productId !== undefined && productId !== null)
      url_ += 'ProductId=' + encodeURIComponent('' + productId) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetAddOn(_response),
        );
      });
  }

  protected processGetAddOn(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfGetAddOnContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetAddOnContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetAddOnContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetAddOnContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetAddOnContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  createAddOn(
    id?: string | null | undefined,
    name?: string | null | undefined,
    price?: number | undefined,
    isEnable?: boolean | null | undefined,
    categoryId?: string[] | null | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<ResponseOfCreateAddOnContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/addon?';
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (name !== undefined && name !== null)
      url_ += 'Name=' + encodeURIComponent('' + name) + '&';
    if (price === null)
      throw new Error("The parameter 'price' cannot be null.");
    else if (price !== undefined)
      url_ += 'Price=' + encodeURIComponent('' + price) + '&';
    if (isEnable !== undefined && isEnable !== null)
      url_ += 'IsEnable=' + encodeURIComponent('' + isEnable) + '&';
    if (categoryId !== undefined && categoryId !== null)
      categoryId &&
        categoryId.forEach((item) => {
          url_ += 'CategoryId=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreateAddOn(_response),
        );
      });
  }

  protected processCreateAddOn(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<ResponseOfCreateAddOnContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfCreateAddOnContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfCreateAddOnContractResponse>
      >(
        new SwaggerResponse<ResponseOfCreateAddOnContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfCreateAddOnContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class CategoryClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getCategory(
    name?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<
    SwaggerResponse<PagedResponseOfListOfGetCategoryContractResponse>
  > {
    let url_ = this.baseUrl + '/api/v1/category?';
    if (name !== undefined && name !== null)
      url_ += 'Name=' + encodeURIComponent('' + name) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetCategory(_response),
        );
      });
  }

  protected processGetCategory(
    response: AxiosResponse,
  ): Promise<
    SwaggerResponse<PagedResponseOfListOfGetCategoryContractResponse>
  > {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfListOfGetCategoryContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfListOfGetCategoryContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfListOfGetCategoryContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfListOfGetCategoryContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class DriverClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getDrivers(
    id?: number | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<ResponseOfListOfGetDriverContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/drivers?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetDrivers(_response),
        );
      });
  }

  protected processGetDrivers(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<ResponseOfListOfGetDriverContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfListOfGetDriverContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<ResponseOfListOfGetDriverContractResponse>
      >(
        new SwaggerResponse<ResponseOfListOfGetDriverContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfListOfGetDriverContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  createDriver(
    id?: string | null | undefined,
    empNo?: number | undefined,
    driverName?: string | null | undefined,
    address?: string | null | undefined,
    city?: string | null | undefined,
    telephone?: string | null | undefined,
    eMail?: string | null | undefined,
    licence?: string | null | undefined,
    vehicleType?: string | null | undefined,
    vehicleNo?: string | null | undefined,
    restaurantId?: string | null | undefined,
    image?: string | null | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<ResponseOfCreateDriverContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/drivers?';
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (empNo === null)
      throw new Error("The parameter 'empNo' cannot be null.");
    else if (empNo !== undefined)
      url_ += 'EmpNo=' + encodeURIComponent('' + empNo) + '&';
    if (driverName !== undefined && driverName !== null)
      url_ += 'DriverName=' + encodeURIComponent('' + driverName) + '&';
    if (address !== undefined && address !== null)
      url_ += 'Address=' + encodeURIComponent('' + address) + '&';
    if (city !== undefined && city !== null)
      url_ += 'City=' + encodeURIComponent('' + city) + '&';
    if (telephone !== undefined && telephone !== null)
      url_ += 'Telephone=' + encodeURIComponent('' + telephone) + '&';
    if (eMail !== undefined && eMail !== null)
      url_ += 'EMail=' + encodeURIComponent('' + eMail) + '&';
    if (licence !== undefined && licence !== null)
      url_ += 'Licence=' + encodeURIComponent('' + licence) + '&';
    if (vehicleType !== undefined && vehicleType !== null)
      url_ += 'VehicleType=' + encodeURIComponent('' + vehicleType) + '&';
    if (vehicleNo !== undefined && vehicleNo !== null)
      url_ += 'VehicleNo=' + encodeURIComponent('' + vehicleNo) + '&';
    if (restaurantId !== undefined && restaurantId !== null)
      url_ += 'RestaurantId=' + encodeURIComponent('' + restaurantId) + '&';
    if (image !== undefined && image !== null)
      url_ += 'Image=' + encodeURIComponent('' + image) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreateDriver(_response),
        );
      });
  }

  protected processCreateDriver(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<ResponseOfCreateDriverContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfCreateDriverContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfCreateDriverContractResponse>
      >(
        new SwaggerResponse<ResponseOfCreateDriverContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfCreateDriverContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateDriver(
    id?: string | null | undefined,
    empNo?: number | undefined,
    driverName?: string | null | undefined,
    address?: string | null | undefined,
    city?: string | null | undefined,
    telephone?: string | null | undefined,
    eMail?: string | null | undefined,
    licence?: string | null | undefined,
    vehicleType?: string | null | undefined,
    vehicleNo?: string | null | undefined,
    restaurantId?: string | null | undefined,
    deviceId?: string | null | undefined,
    image?: string | null | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<ResponseOfUpdateDriverContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/drivers/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (empNo === null)
      throw new Error("The parameter 'empNo' cannot be null.");
    else if (empNo !== undefined)
      url_ += 'EmpNo=' + encodeURIComponent('' + empNo) + '&';
    if (driverName !== undefined && driverName !== null)
      url_ += 'DriverName=' + encodeURIComponent('' + driverName) + '&';
    if (address !== undefined && address !== null)
      url_ += 'Address=' + encodeURIComponent('' + address) + '&';
    if (city !== undefined && city !== null)
      url_ += 'City=' + encodeURIComponent('' + city) + '&';
    if (telephone !== undefined && telephone !== null)
      url_ += 'Telephone=' + encodeURIComponent('' + telephone) + '&';
    if (eMail !== undefined && eMail !== null)
      url_ += 'EMail=' + encodeURIComponent('' + eMail) + '&';
    if (licence !== undefined && licence !== null)
      url_ += 'Licence=' + encodeURIComponent('' + licence) + '&';
    if (vehicleType !== undefined && vehicleType !== null)
      url_ += 'VehicleType=' + encodeURIComponent('' + vehicleType) + '&';
    if (vehicleNo !== undefined && vehicleNo !== null)
      url_ += 'VehicleNo=' + encodeURIComponent('' + vehicleNo) + '&';
    if (restaurantId !== undefined && restaurantId !== null)
      url_ += 'RestaurantId=' + encodeURIComponent('' + restaurantId) + '&';
    if (deviceId !== undefined && deviceId !== null)
      url_ += 'DeviceId=' + encodeURIComponent('' + deviceId) + '&';
    if (image !== undefined && image !== null)
      url_ += 'Image=' + encodeURIComponent('' + image) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'PUT',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdateDriver(_response),
        );
      });
  }

  protected processUpdateDriver(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<ResponseOfUpdateDriverContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfUpdateDriverContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfUpdateDriverContractResponse>
      >(
        new SwaggerResponse<ResponseOfUpdateDriverContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfUpdateDriverContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class FileClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  viewImage(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/viewImage/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processViewImage(_response),
        );
      });
  }

  protected processViewImage(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  admin(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Admin/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processAdmin(_response),
        );
      });
  }

  protected processAdmin(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  category(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Category/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCategory(_response),
        );
      });
  }

  protected processCategory(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  product(
    id: string | null,
    tenantId: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Product/{id},{tenantId}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processProduct(_response),
        );
      });
  }

  protected processProduct(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  gallery(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Gallery/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGallery(_response),
        );
      });
  }

  protected processGallery(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  default(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Default/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processDefault(_response),
        );
      });
  }

  protected processDefault(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  users(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Users/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUsers(_response),
        );
      });
  }

  protected processUsers(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  driver(
    id: string | null,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + '/api/v1/File/Driver/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      responseType: 'blob',
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/octet-stream',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processDriver(_response),
        );
      });
  }

  protected processDriver(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        }),
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }
}

export class MenuClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getMenu(
    id?: string | null | undefined,
    name?: string | null | undefined,
    price?: number | undefined,
    isEnable?: boolean | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfListOfGetMenuContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/menu?';
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (name !== undefined && name !== null)
      url_ += 'Name=' + encodeURIComponent('' + name) + '&';
    if (price === null)
      throw new Error("The parameter 'price' cannot be null.");
    else if (price !== undefined)
      url_ += 'Price=' + encodeURIComponent('' + price) + '&';
    if (isEnable !== undefined && isEnable !== null)
      url_ += 'IsEnable=' + encodeURIComponent('' + isEnable) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetMenu(_response),
        );
      });
  }

  protected processGetMenu(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfListOfGetMenuContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfListOfGetMenuContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfListOfGetMenuContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfListOfGetMenuContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfListOfGetMenuContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class OrdersClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getOrders(
    orderTypes?: string[] | null | undefined,
    isDriver?: boolean | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfListOfGetOrderContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/order?';
    if (orderTypes !== undefined && orderTypes !== null)
      orderTypes &&
        orderTypes.forEach((item) => {
          url_ += 'OrderTypes=' + encodeURIComponent('' + item) + '&';
        });
    if (isDriver === null)
      throw new Error("The parameter 'isDriver' cannot be null.");
    else if (isDriver !== undefined)
      url_ += 'IsDriver=' + encodeURIComponent('' + isDriver) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetOrders(_response),
        );
      });
  }

  protected processGetOrders(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfListOfGetOrderContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfListOfGetOrderContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfListOfGetOrderContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfListOfGetOrderContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfListOfGetOrderContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateOrderStatus(
    id: string,
    orderId?: string | null | undefined,
    reason?: string | null | undefined,
    driverId?: string | null | undefined,
    orderStatus?: OrderStatus | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<ResponseOfUpdateOrderContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/order/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (orderId !== undefined && orderId !== null)
      url_ += 'OrderId=' + encodeURIComponent('' + orderId) + '&';
    if (reason !== undefined && reason !== null)
      url_ += 'Reason=' + encodeURIComponent('' + reason) + '&';
    if (driverId !== undefined && driverId !== null)
      url_ += 'DriverId=' + encodeURIComponent('' + driverId) + '&';
    if (orderStatus === null)
      throw new Error("The parameter 'orderStatus' cannot be null.");
    else if (orderStatus !== undefined)
      url_ += 'OrderStatus=' + encodeURIComponent('' + orderStatus) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'PUT',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) =>
            this.processUpdateOrderStatus(_response),
        );
      });
  }

  protected processUpdateOrderStatus(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<ResponseOfUpdateOrderContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfUpdateOrderContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfUpdateOrderContractResponse>
      >(
        new SwaggerResponse<ResponseOfUpdateOrderContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfUpdateOrderContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class PortionClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getPortion(
    productId?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfGetPortionContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/portion?';
    if (productId !== undefined && productId !== null)
      url_ += 'ProductId=' + encodeURIComponent('' + productId) + '&';
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetPortion(_response),
        );
      });
  }

  protected processGetPortion(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfGetPortionContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetPortionContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetPortionContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetPortionContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetPortionContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class RestaurantClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getRestaurant(
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfGetRestaurantContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/restaurant';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetRestaurant(_response),
        );
      });
  }

  protected processGetRestaurant(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfGetRestaurantContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetRestaurantContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetRestaurantContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetRestaurantContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetRestaurantContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class UserProfileClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  getUserProfile(
    isDriver?: boolean | undefined,
    userId?: string | null | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<PagedResponseOfGetUserProfileContractResponse>> {
    let url_ = this.baseUrl + '/api/v1/userProfile?';
    if (isDriver === null)
      throw new Error("The parameter 'isDriver' cannot be null.");
    else if (isDriver !== undefined)
      url_ += 'IsDriver=' + encodeURIComponent('' + isDriver) + '&';
    if (userId !== undefined && userId !== null)
      url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetUserProfile(_response),
        );
      });
  }

  protected processGetUserProfile(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<PagedResponseOfGetUserProfileContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetUserProfileContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetUserProfileContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetUserProfileContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetUserProfileContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateUserProfile(
    id: string,
    deviceId?: string | null | undefined,
    pushToken?: string | null | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<
    SwaggerResponse<PagedResponseOfUpdateUserProfileContractResponse>
  > {
    let url_ = this.baseUrl + '/api/v1/userProfile/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (deviceId !== undefined && deviceId !== null)
      url_ += 'DeviceId=' + encodeURIComponent('' + deviceId) + '&';
    if (pushToken !== undefined && pushToken !== null)
      url_ += 'PushToken=' + encodeURIComponent('' + pushToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'PUT',
      url: url_,
      headers: {
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) =>
            this.processUpdateUserProfile(_response),
        );
      });
  }

  protected processUpdateUserProfile(
    response: AxiosResponse,
  ): Promise<
    SwaggerResponse<PagedResponseOfUpdateUserProfileContractResponse>
  > {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfUpdateUserProfileContractResponse.fromJS(
        resultData200,
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfUpdateUserProfileContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfUpdateUserProfileContractResponse>(
          status,
          _headers,
          result200,
        ),
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result412,
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfUpdateUserProfileContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class IdentityClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance,
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('https://empite.host');
  }

  register(
    request: UserRegistrationRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + '/api/v1/identity/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processRegister(_response),
        );
      });
  }

  protected processRegister(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201),
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = AuthFailedResponse.fromJS(resultData500);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result500,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  login(
    request: UserLoginRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + '/api/v1/identity/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processLogin(_response),
        );
      });
  }

  protected processLogin(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201),
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AuthSuccessResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result200),
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }

  refresh(
    request: RefreshTokenRequest,
    cancelToken?: CancelToken | undefined,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + '/api/v1/identity/refresh';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processRefresh(_response),
        );
      });
  }

  protected processRefresh(
    response: AxiosResponse,
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201),
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AuthSuccessResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result200),
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        'A server side error occurred.',
        status,
        _responseText,
        _headers,
        result400,
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null),
    );
  }
}

export class PagedResponseOfGetAddOnContractResponse
  implements IPagedResponseOfGetAddOnContractResponse {
  data?: GetAddOnContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetAddOnContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(GetAddOnContractResponse.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetAddOnContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfGetAddOnContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetAddOnContractResponse {
  data?: GetAddOnContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetAddOnContractResponse implements IGetAddOnContractResponse {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;
  deletedAt?: moment.Moment | undefined;

  constructor(data?: IGetAddOnContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.isEnable = _data['isEnable'];
      this.deletedAt = _data['deletedAt']
        ? moment(_data['deletedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetAddOnContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetAddOnContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['price'] = this.price;
    data['isEnable'] = this.isEnable;
    data['deletedAt'] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IGetAddOnContractResponse {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
  deletedAt?: moment.Moment | undefined;
}

export class LinkBase implements ILinkBase {
  self?: LinkHref | undefined;

  constructor(data?: ILinkBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.self = _data['self']
        ? LinkHref.fromJS(_data['self'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): LinkBase {
    data = typeof data === 'object' ? data : {};
    let result = new LinkBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['self'] = this.self ? this.self.toJSON() : <any>undefined;
    return data;
  }
}

export interface ILinkBase {
  self?: LinkHref | undefined;
}

export class Links extends LinkBase implements ILinks {
  next?: LinkHref | undefined;
  prev?: LinkHref | undefined;
  first?: LinkHref | undefined;
  last?: LinkHref | undefined;

  constructor(data?: ILinks) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.next = _data['next']
        ? LinkHref.fromJS(_data['next'])
        : <any>undefined;
      this.prev = _data['prev']
        ? LinkHref.fromJS(_data['prev'])
        : <any>undefined;
      this.first = _data['first']
        ? LinkHref.fromJS(_data['first'])
        : <any>undefined;
      this.last = _data['last']
        ? LinkHref.fromJS(_data['last'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Links {
    data = typeof data === 'object' ? data : {};
    let result = new Links();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['next'] = this.next ? this.next.toJSON() : <any>undefined;
    data['prev'] = this.prev ? this.prev.toJSON() : <any>undefined;
    data['first'] = this.first ? this.first.toJSON() : <any>undefined;
    data['last'] = this.last ? this.last.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ILinks extends ILinkBase {
  next?: LinkHref | undefined;
  prev?: LinkHref | undefined;
  first?: LinkHref | undefined;
  last?: LinkHref | undefined;
}

export class LinkHref implements ILinkHref {
  href?: string | undefined;

  constructor(data?: ILinkHref) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.href = _data['href'];
    }
  }

  static fromJS(data: any): LinkHref {
    data = typeof data === 'object' ? data : {};
    let result = new LinkHref();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['href'] = this.href;
    return data;
  }
}

export interface ILinkHref {
  href?: string | undefined;
}

export class BadResponse implements IBadResponse {
  errors?: BadResponseHolder[] | undefined;

  constructor(data?: IBadResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors'])
          this.errors!.push(BadResponseHolder.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BadResponse {
    data = typeof data === 'object' ? data : {};
    let result = new BadResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item.toJSON());
    }
    return data;
  }
}

export interface IBadResponse {
  errors?: BadResponseHolder[] | undefined;
}

export class BadResponseHolder implements IBadResponseHolder {
  status!: number;
  error?: string | undefined;

  constructor(data?: IBadResponseHolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data['status'];
      this.error = _data['error'];
    }
  }

  static fromJS(data: any): BadResponseHolder {
    data = typeof data === 'object' ? data : {};
    let result = new BadResponseHolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['status'] = this.status;
    data['error'] = this.error;
    return data;
  }
}

export interface IBadResponseHolder {
  status: number;
  error?: string | undefined;
}

export class ErrorResponse implements IErrorResponse {
  errors?: ErrorModel[] | undefined;

  constructor(data?: IErrorResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors'])
          this.errors!.push(ErrorModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ErrorResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ErrorResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item.toJSON());
    }
    return data;
  }
}

export interface IErrorResponse {
  errors?: ErrorModel[] | undefined;
}

export class ErrorModel implements IErrorModel {
  fieldName?: string | undefined;
  message?: string | undefined;

  constructor(data?: IErrorModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data['fieldName'];
      this.message = _data['message'];
    }
  }

  static fromJS(data: any): ErrorModel {
    data = typeof data === 'object' ? data : {};
    let result = new ErrorModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fieldName'] = this.fieldName;
    data['message'] = this.message;
    return data;
  }
}

export interface IErrorModel {
  fieldName?: string | undefined;
  message?: string | undefined;
}

export class ResponseOfCreateAddOnContractResponse
  implements IResponseOfCreateAddOnContractResponse {
  data?: CreateAddOnContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfCreateAddOnContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? CreateAddOnContractResponse.fromJS(_data['data'])
        : <any>undefined;
      this._links = _data['_links']
        ? LinkBase.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfCreateAddOnContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseOfCreateAddOnContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfCreateAddOnContractResponse {
  data?: CreateAddOnContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class CreateAddOnContractResponse
  implements ICreateAddOnContractResponse {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;

  constructor(data?: ICreateAddOnContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.isEnable = _data['isEnable'];
    }
  }

  static fromJS(data: any): CreateAddOnContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAddOnContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['price'] = this.price;
    data['isEnable'] = this.isEnable;
    return data;
  }
}

export interface ICreateAddOnContractResponse {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
}

export class PagedResponseOfListOfGetCategoryContractResponse
  implements IPagedResponseOfListOfGetCategoryContractResponse {
  data?: GetCategoryContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfListOfGetCategoryContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(item);
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfListOfGetCategoryContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfListOfGetCategoryContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item);
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfListOfGetCategoryContractResponse {
  data?: GetCategoryContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetCategoryContractResponse
  implements IGetCategoryContractResponse {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;

  constructor(data?: IGetCategoryContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.shortDescription = _data['shortDescription'];
      this.longDescription = _data['longDescription'];
      this.imagePath = _data['imagePath'];
      this.restaurantId = _data['restaurantId'];
      this.isEnable = _data['isEnable'];
      this.displayOrder = _data['displayOrder'];
      this.deleteAt = _data['deleteAt']
        ? moment(_data['deleteAt'].toString())
        : <any>undefined;
      this.availableFrom = _data['availableFrom']
        ? moment(_data['availableFrom'].toString())
        : <any>undefined;
      this.availableTo = _data['availableTo']
        ? moment(_data['availableTo'].toString())
        : <any>undefined;
      this.image = _data['image']
        ? MemoryStream.fromJS(_data['image'])
        : <any>undefined;
      if (Array.isArray(_data['portionIds'])) {
        this.portionIds = [] as any;
        for (let item of _data['portionIds']) this.portionIds!.push(item);
      }
    }
  }

  static fromJS(data: any): GetCategoryContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetCategoryContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['shortDescription'] = this.shortDescription;
    data['longDescription'] = this.longDescription;
    data['imagePath'] = this.imagePath;
    data['restaurantId'] = this.restaurantId;
    data['isEnable'] = this.isEnable;
    data['displayOrder'] = this.displayOrder;
    data['deleteAt'] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data['availableFrom'] = this.availableFrom
      ? this.availableFrom.toISOString()
      : <any>undefined;
    data['availableTo'] = this.availableTo
      ? this.availableTo.toISOString()
      : <any>undefined;
    data['image'] = this.image ? this.image.toJSON() : <any>undefined;
    if (Array.isArray(this.portionIds)) {
      data['portionIds'] = [];
      for (let item of this.portionIds) data['portionIds'].push(item);
    }
    return data;
  }
}

export interface IGetCategoryContractResponse {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {
  constructor(data?: IMarshalByRefObject) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): MarshalByRefObject {
    data = typeof data === 'object' ? data : {};
    throw new Error(
      "The abstract class 'MarshalByRefObject' cannot be instantiated.",
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IMarshalByRefObject {}

export abstract class Stream extends MarshalByRefObject implements IStream {
  canTimeout!: boolean;
  readTimeout!: number;
  writeTimeout!: number;

  constructor(data?: IStream) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.canTimeout = _data['canTimeout'];
      this.readTimeout = _data['readTimeout'];
      this.writeTimeout = _data['writeTimeout'];
    }
  }

  static fromJS(data: any): Stream {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'Stream' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canTimeout'] = this.canTimeout;
    data['readTimeout'] = this.readTimeout;
    data['writeTimeout'] = this.writeTimeout;
    super.toJSON(data);
    return data;
  }
}

export interface IStream extends IMarshalByRefObject {
  canTimeout: boolean;
  readTimeout: number;
  writeTimeout: number;
}

export class MemoryStream extends Stream implements IMemoryStream {
  canRead!: boolean;
  canSeek!: boolean;
  canWrite!: boolean;
  capacity!: number;
  length!: number;
  position!: number;

  constructor(data?: IMemoryStream) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.canRead = _data['canRead'];
      this.canSeek = _data['canSeek'];
      this.canWrite = _data['canWrite'];
      this.capacity = _data['capacity'];
      this.length = _data['length'];
      this.position = _data['position'];
    }
  }

  static fromJS(data: any): MemoryStream {
    data = typeof data === 'object' ? data : {};
    let result = new MemoryStream();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canRead'] = this.canRead;
    data['canSeek'] = this.canSeek;
    data['canWrite'] = this.canWrite;
    data['capacity'] = this.capacity;
    data['length'] = this.length;
    data['position'] = this.position;
    super.toJSON(data);
    return data;
  }
}

export interface IMemoryStream extends IStream {
  canRead: boolean;
  canSeek: boolean;
  canWrite: boolean;
  capacity: number;
  length: number;
  position: number;
}

export class ResponseOfListOfGetDriverContractResponse
  implements IResponseOfListOfGetDriverContractResponse {
  data?: GetDriverContractResponse[] | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfListOfGetDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(GetDriverContractResponse.fromJS(item));
      }
      this._links = _data['_links']
        ? LinkBase.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfListOfGetDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseOfListOfGetDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfListOfGetDriverContractResponse {
  data?: GetDriverContractResponse[] | undefined;
  _links?: LinkBase | undefined;
}

export class GetDriverContractResponse implements IGetDriverContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;

  constructor(data?: IGetDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.licence = _data['licence'];
      this.vehicleType = _data['vehicleType'];
      this.vehicleNo = _data['vehicleNo'];
      this.restaurantId = _data['restaurantId'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): GetDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['address'] = this.address;
    data['city'] = this.city;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['licence'] = this.licence;
    data['vehicleType'] = this.vehicleType;
    data['vehicleNo'] = this.vehicleNo;
    data['restaurantId'] = this.restaurantId;
    data['image'] = this.image;
    return data;
  }
}

export interface IGetDriverContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;
}

export class ResponseOfUpdateDriverContractResponse
  implements IResponseOfUpdateDriverContractResponse {
  data?: UpdateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfUpdateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? UpdateDriverContractResponse.fromJS(_data['data'])
        : <any>undefined;
      this._links = _data['_links']
        ? LinkBase.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfUpdateDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseOfUpdateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfUpdateDriverContractResponse {
  data?: UpdateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class UpdateDriverContractResponse
  implements IUpdateDriverContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  deviceId?: string | undefined;
  image?: string | undefined;

  constructor(data?: IUpdateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.licence = _data['licence'];
      this.vehicleType = _data['vehicleType'];
      this.vehicleNo = _data['vehicleNo'];
      this.restaurantId = _data['restaurantId'];
      this.deviceId = _data['deviceId'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): UpdateDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['address'] = this.address;
    data['city'] = this.city;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['licence'] = this.licence;
    data['vehicleType'] = this.vehicleType;
    data['vehicleNo'] = this.vehicleNo;
    data['restaurantId'] = this.restaurantId;
    data['deviceId'] = this.deviceId;
    data['image'] = this.image;
    return data;
  }
}

export interface IUpdateDriverContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  deviceId?: string | undefined;
  image?: string | undefined;
}

export class ResponseOfCreateDriverContractResponse
  implements IResponseOfCreateDriverContractResponse {
  data?: CreateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfCreateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? CreateDriverContractResponse.fromJS(_data['data'])
        : <any>undefined;
      this._links = _data['_links']
        ? LinkBase.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfCreateDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseOfCreateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfCreateDriverContractResponse {
  data?: CreateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class CreateDriverContractResponse
  implements ICreateDriverContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;

  constructor(data?: ICreateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.licence = _data['licence'];
      this.vehicleType = _data['vehicleType'];
      this.vehicleNo = _data['vehicleNo'];
      this.restaurantId = _data['restaurantId'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): CreateDriverContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['address'] = this.address;
    data['city'] = this.city;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['licence'] = this.licence;
    data['vehicleType'] = this.vehicleType;
    data['vehicleNo'] = this.vehicleNo;
    data['restaurantId'] = this.restaurantId;
    data['image'] = this.image;
    return data;
  }
}

export interface ICreateDriverContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;
}

export class PagedResponseOfListOfGetMenuContractResponse
  implements IPagedResponseOfListOfGetMenuContractResponse {
  data?: GetMenuContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfListOfGetMenuContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(item);
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfListOfGetMenuContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfListOfGetMenuContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item);
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfListOfGetMenuContractResponse {
  data?: GetMenuContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetMenuContractResponse implements IGetMenuContractResponse {
  groupedProductList?: MenuListModel[][] | undefined;

  constructor(data?: IGetMenuContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['groupedProductList'])) {
        this.groupedProductList = [] as any;
        for (let item of _data['groupedProductList'])
          this.groupedProductList!.push(item);
      }
    }
  }

  static fromJS(data: any): GetMenuContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetMenuContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.groupedProductList)) {
      data['groupedProductList'] = [];
      for (let item of this.groupedProductList)
        data['groupedProductList'].push(item);
    }
    return data;
  }
}

export interface IGetMenuContractResponse {
  groupedProductList?: MenuListModel[][] | undefined;
}

export class MenuListModel implements IMenuListModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;
  mainImage?: string | undefined;
  unitPrice?: number | undefined;
  toppingId?: string | undefined;
  categoryPortion?: CategoryPortion | undefined;
  category?: Category | undefined;

  constructor(data?: IMenuListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.isEnable = _data['isEnable'];
      this.mainImage = _data['mainImage'];
      this.unitPrice = _data['unitPrice'];
      this.toppingId = _data['toppingId'];
      this.categoryPortion = _data['categoryPortion']
        ? CategoryPortion.fromJS(_data['categoryPortion'])
        : <any>undefined;
      this.category = _data['category']
        ? Category.fromJS(_data['category'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MenuListModel {
    data = typeof data === 'object' ? data : {};
    let result = new MenuListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['price'] = this.price;
    data['isEnable'] = this.isEnable;
    data['mainImage'] = this.mainImage;
    data['unitPrice'] = this.unitPrice;
    data['toppingId'] = this.toppingId;
    data['categoryPortion'] = this.categoryPortion
      ? this.categoryPortion.toJSON()
      : <any>undefined;
    data['category'] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface IMenuListModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
  mainImage?: string | undefined;
  unitPrice?: number | undefined;
  toppingId?: string | undefined;
  categoryPortion?: CategoryPortion | undefined;
  category?: Category | undefined;
}

export class CategoryPortion implements ICategoryPortion {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId!: number;

  constructor(data?: ICategoryPortion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.portionsNAme = _data['portionsNAme'];
      this.portionSizeId = _data['portionSizeId'];
    }
  }

  static fromJS(data: any): CategoryPortion {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryPortion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['portionsNAme'] = this.portionsNAme;
    data['portionSizeId'] = this.portionSizeId;
    return data;
  }
}

export interface ICategoryPortion {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId: number;
}

export class Category implements ICategory {
  id?: string | undefined;
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  isEnable?: boolean | undefined;

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.shortDescription = _data['shortDescription'];
      this.longDescription = _data['longDescription'];
      this.imagePath = _data['imagePath'];
      this.isEnable = _data['isEnable'];
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === 'object' ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['shortDescription'] = this.shortDescription;
    data['longDescription'] = this.longDescription;
    data['imagePath'] = this.imagePath;
    data['isEnable'] = this.isEnable;
    return data;
  }
}

export interface ICategory {
  id?: string | undefined;
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  isEnable?: boolean | undefined;
}

export class PagedResponseOfListOfGetOrderContractResponse
  implements IPagedResponseOfListOfGetOrderContractResponse {
  data?: GetOrderContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfListOfGetOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(item);
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfListOfGetOrderContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfListOfGetOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item);
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfListOfGetOrderContractResponse {
  data?: GetOrderContractResponse[][] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetOrderContractResponse implements IGetOrderContractResponse {
  id?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  phone?: string | undefined;
  displayId?: string | undefined;
  orderDetails?: OrderDetail[] | undefined;
  driver?: DriverModel | undefined;
  customerName?: string | undefined;
  subTotal?: string | undefined;
  deliveryFee?: string | undefined;
  total?: string | undefined;
  duration?: string | undefined;
  status?: string | undefined;
  distance?: string | undefined;
  createdAt!: moment.Moment;

  constructor(data?: IGetOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.postalCode = _data['postalCode'];
      this.phone = _data['phone'];
      this.displayId = _data['displayId'];
      if (Array.isArray(_data['orderDetails'])) {
        this.orderDetails = [] as any;
        for (let item of _data['orderDetails'])
          this.orderDetails!.push(OrderDetail.fromJS(item));
      }
      this.driver = _data['driver']
        ? DriverModel.fromJS(_data['driver'])
        : <any>undefined;
      this.customerName = _data['customerName'];
      this.subTotal = _data['subTotal'];
      this.deliveryFee = _data['deliveryFee'];
      this.total = _data['total'];
      this.duration = _data['duration'];
      this.status = _data['status'];
      this.distance = _data['distance'];
      this.createdAt = _data['createdAt']
        ? moment(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetOrderContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['address'] = this.address;
    data['city'] = this.city;
    data['postalCode'] = this.postalCode;
    data['phone'] = this.phone;
    data['displayId'] = this.displayId;
    if (Array.isArray(this.orderDetails)) {
      data['orderDetails'] = [];
      for (let item of this.orderDetails)
        data['orderDetails'].push(item.toJSON());
    }
    data['driver'] = this.driver ? this.driver.toJSON() : <any>undefined;
    data['customerName'] = this.customerName;
    data['subTotal'] = this.subTotal;
    data['deliveryFee'] = this.deliveryFee;
    data['total'] = this.total;
    data['duration'] = this.duration;
    data['status'] = this.status;
    data['distance'] = this.distance;
    data['createdAt'] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IGetOrderContractResponse {
  id?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  phone?: string | undefined;
  displayId?: string | undefined;
  orderDetails?: OrderDetail[] | undefined;
  driver?: DriverModel | undefined;
  customerName?: string | undefined;
  subTotal?: string | undefined;
  deliveryFee?: string | undefined;
  total?: string | undefined;
  duration?: string | undefined;
  status?: string | undefined;
  distance?: string | undefined;
  createdAt: moment.Moment;
}

export class OrderDetail implements IOrderDetail {
  id?: string | undefined;
  product?: Product | undefined;
  quantity!: number;
  price?: string | undefined;

  constructor(data?: IOrderDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.product = _data['Product']
        ? Product.fromJS(_data['Product'])
        : <any>undefined;
      this.quantity = _data['quantity'];
      this.price = _data['price'];
    }
  }

  static fromJS(data: any): OrderDetail {
    data = typeof data === 'object' ? data : {};
    let result = new OrderDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['Product'] = this.product ? this.product.toJSON() : <any>undefined;
    data['quantity'] = this.quantity;
    data['price'] = this.price;
    return data;
  }
}

export interface IOrderDetail {
  id?: string | undefined;
  product?: Product | undefined;
  quantity: number;
  price?: string | undefined;
}

export class Product implements IProduct {
  productId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  mainImage?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  image?: MemoryStream | undefined;

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['ProductId'];
      this.name = _data['Name'];
      this.description = _data['description'];
      this.mainImage = _data['mainImage'];
      this.deleteAt = _data['deleteAt']
        ? moment(_data['deleteAt'].toString())
        : <any>undefined;
      this.image = _data['image']
        ? MemoryStream.fromJS(_data['image'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === 'object' ? data : {};
    let result = new Product();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ProductId'] = this.productId;
    data['Name'] = this.name;
    data['description'] = this.description;
    data['mainImage'] = this.mainImage;
    data['deleteAt'] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data['image'] = this.image ? this.image.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProduct {
  productId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  mainImage?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
}

export class DriverModel implements IDriverModel {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  deviceId?: string | undefined;
  image?: string | undefined;

  constructor(data?: IDriverModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.licence = _data['licence'];
      this.vehicleType = _data['vehicleType'];
      this.vehicleNo = _data['vehicleNo'];
      this.restaurantId = _data['restaurantId'];
      this.deviceId = _data['deviceId'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): DriverModel {
    data = typeof data === 'object' ? data : {};
    let result = new DriverModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['address'] = this.address;
    data['city'] = this.city;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['licence'] = this.licence;
    data['vehicleType'] = this.vehicleType;
    data['vehicleNo'] = this.vehicleNo;
    data['restaurantId'] = this.restaurantId;
    data['deviceId'] = this.deviceId;
    data['image'] = this.image;
    return data;
  }
}

export interface IDriverModel {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  deviceId?: string | undefined;
  image?: string | undefined;
}

export class ResponseOfUpdateOrderContractResponse
  implements IResponseOfUpdateOrderContractResponse {
  data?: UpdateOrderContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfUpdateOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? UpdateOrderContractResponse.fromJS(_data['data'])
        : <any>undefined;
      this._links = _data['_links']
        ? LinkBase.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfUpdateOrderContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseOfUpdateOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfUpdateOrderContractResponse {
  data?: UpdateOrderContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class UpdateOrderContractResponse
  implements IUpdateOrderContractResponse {
  orderId?: string | undefined;
  isSuccess!: boolean;

  constructor(data?: IUpdateOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data['orderId'];
      this.isSuccess = _data['isSuccess'];
    }
  }

  static fromJS(data: any): UpdateOrderContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderId'] = this.orderId;
    data['isSuccess'] = this.isSuccess;
    return data;
  }
}

export interface IUpdateOrderContractResponse {
  orderId?: string | undefined;
  isSuccess: boolean;
}

export enum OrderStatus {
  Recieved = 1,
  Pending = 2,
  Accepted = 3,
  Canceled = 4,
  WaitingForDriver = 5,
  DriverAccepted = 6,
  DriverRejected = 7,
  OnTheWay = 8,
  Done = 9,
  ReadyOrder = 10,
}

export class PagedResponseOfGetPortionContractResponse
  implements IPagedResponseOfGetPortionContractResponse {
  data?: GetPortionContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetPortionContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(GetPortionContractResponse.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetPortionContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfGetPortionContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetPortionContractResponse {
  data?: GetPortionContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetPortionContractResponse implements IGetPortionContractResponse {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId!: number;
  offerPrice!: number;
  regularPrice!: number;

  constructor(data?: IGetPortionContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.portionsNAme = _data['portionsNAme'];
      this.portionSizeId = _data['portionSizeId'];
      this.offerPrice = _data['offerPrice'];
      this.regularPrice = _data['regularPrice'];
    }
  }

  static fromJS(data: any): GetPortionContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetPortionContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['portionsNAme'] = this.portionsNAme;
    data['portionSizeId'] = this.portionSizeId;
    data['offerPrice'] = this.offerPrice;
    data['regularPrice'] = this.regularPrice;
    return data;
  }
}

export interface IGetPortionContractResponse {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId: number;
  offerPrice: number;
  regularPrice: number;
}

export class PagedResponseOfGetRestaurantContractResponse
  implements IPagedResponseOfGetRestaurantContractResponse {
  data?: GetRestaurantContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetRestaurantContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(GetRestaurantContractResponse.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetRestaurantContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfGetRestaurantContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetRestaurantContractResponse {
  data?: GetRestaurantContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetRestaurantContractResponse
  implements IGetRestaurantContractResponse {
  restaurantModel?: RestaurantContractModel | undefined;

  constructor(data?: IGetRestaurantContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.restaurantModel = _data['restaurantModel']
        ? RestaurantContractModel.fromJS(_data['restaurantModel'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetRestaurantContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetRestaurantContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['restaurantModel'] = this.restaurantModel
      ? this.restaurantModel.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IGetRestaurantContractResponse {
  restaurantModel?: RestaurantContractModel | undefined;
}

export class RestaurantContractModel implements IRestaurantContractModel {
  id?: string | undefined;
  userId?: number | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;

  constructor(data?: IRestaurantContractModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      this.name = _data['name'];
      this.phoneNo = _data['phoneNo'];
      this.address = _data['address'];
      this.postalCode = _data['postalCode'];
      this.email = _data['email'];
      this.image = _data['image'];
    }
  }

  static fromJS(data: any): RestaurantContractModel {
    data = typeof data === 'object' ? data : {};
    let result = new RestaurantContractModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    data['name'] = this.name;
    data['phoneNo'] = this.phoneNo;
    data['address'] = this.address;
    data['postalCode'] = this.postalCode;
    data['email'] = this.email;
    data['image'] = this.image;
    return data;
  }
}

export interface IRestaurantContractModel {
  id?: string | undefined;
  userId?: number | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
}

export class PagedResponseOfGetUserProfileContractResponse
  implements IPagedResponseOfGetUserProfileContractResponse {
  data?: GetUserProfileContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetUserProfileContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(GetUserProfileContractResponse.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetUserProfileContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfGetUserProfileContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetUserProfileContractResponse {
  data?: GetUserProfileContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetUserProfileContractResponse
  implements IGetUserProfileContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  image?: string | undefined;
  address?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IGetUserProfileContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.image = _data['image'];
      this.address = _data['address'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): GetUserProfileContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserProfileContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['image'] = this.image;
    data['address'] = this.address;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IGetUserProfileContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  image?: string | undefined;
  address?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  phoneNumber?: string | undefined;
}

export class PagedResponseOfUpdateUserProfileContractResponse
  implements IPagedResponseOfUpdateUserProfileContractResponse {
  data?: UpdateUserProfileContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfUpdateUserProfileContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data'])
          this.data!.push(UpdateUserProfileContractResponse.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      this._links = _data['_links']
        ? Links.fromJS(_data['_links'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfUpdateUserProfileContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResponseOfUpdateUserProfileContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['_links'] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfUpdateUserProfileContractResponse {
  data?: UpdateUserProfileContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class UpdateUserProfileContractResponse
  implements IUpdateUserProfileContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  image?: string | undefined;
  address?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IUpdateUserProfileContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.empNo = _data['empNo'];
      this.driverName = _data['driverName'];
      this.image = _data['image'];
      this.address = _data['address'];
      this.telephone = _data['telephone'];
      this.eMail = _data['eMail'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): UpdateUserProfileContractResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserProfileContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['empNo'] = this.empNo;
    data['driverName'] = this.driverName;
    data['image'] = this.image;
    data['address'] = this.address;
    data['telephone'] = this.telephone;
    data['eMail'] = this.eMail;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IUpdateUserProfileContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  image?: string | undefined;
  address?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  phoneNumber?: string | undefined;
}

export class AuthSuccessResponse implements IAuthSuccessResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IAuthSuccessResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): AuthSuccessResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AuthSuccessResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IAuthSuccessResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class AuthFailedResponse implements IAuthFailedResponse {
  errors?: string[] | undefined;

  constructor(data?: IAuthFailedResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): AuthFailedResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AuthFailedResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IAuthFailedResponse {
  errors?: string[] | undefined;
}

export class UserRegistrationRequest implements IUserRegistrationRequest {
  email?: string | undefined;
  password?: string | undefined;
  roles?: string[] | undefined;

  constructor(data?: IUserRegistrationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): UserRegistrationRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UserRegistrationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface IUserRegistrationRequest {
  email?: string | undefined;
  password?: string | undefined;
  roles?: string[] | undefined;
}

export class UserLoginRequest implements IUserLoginRequest {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUserLoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): UserLoginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface IUserLoginRequest {
  email?: string | undefined;
  password?: string | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IRefreshTokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshTokenRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshTokenRequest {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class SwaggerResponse<TResult> {
  status: number;
  headers: {[key: string]: any};
  result: TResult;

  constructor(status: number, headers: {[key: string]: any}, result: TResult) {
    this.status = status;
    this.headers = headers;
    this.result = result;
  }
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: {[name: string]: any};
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: {[key: string]: any};
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: {[key: string]: any},
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: {[key: string]: any},
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */

export class IConfig {
  /**
   * Returns a valid value for the Authorization header.
   * Used to dynamically inject the current auth header.
   */
  getAuthorization() {
    //return `Brearer ${TestService.Token()}`;
    return `Bearer ${authToken}`;
  }
  getTenantId() {
    //return `Brearer ${TestService.Token()}`;
    return `${tenantId}`;
  }
  baseUrl() {
    return 'https://api.restaurant-qa-two.emp-host.com';
  }
}
